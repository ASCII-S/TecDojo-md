---
jupytext:
  formats: "md:markdown,ipynb/C++primer/06-\u51FD\u6570.ipynb:notebook"
  text_representation:
    extension: .md
    format_name: markdown
    format_version: '1.3'
    jupytext_version: 1.13.8
kernelspec:
  display_name: C++
  language: C++
  name: xcpp
language_info:
  codemirror_mode: text/x-c++src
  file_extension: .cpp
  mimetype: text/x-c++src
  name: c++
  version: '11'
---

[[C++ primer]]
---
# 函数基础
**调用运算符的基本概念**
1. **调用运算符是可重载的**：
    - 调用运算符 `**()**` 是 C++ 的一个特殊运算符，可以通过在类中重载该运算符，使类的对象具备类似函数的行为。
2. **语法**：
    
    ```C++
    return_type operator()(parameters) const {
    // 函数体
    }
    ```
    
    - `**return_type**` 是调用运算符的返回值类型。
    - `**parameters**` 是调用运算符的参数列表。
    - 可以根据需要定义为 `**const**` 或非 `**const**`。
---
**函数的形参列表**
**1.** `**void f1()**`**（隐式空形参列表）**
- 在 C++ 中，`**void f1()**` 定义了一个**不接受参数**的函数。
- 它表示函数没有形参，但**编译器不检查**调用时传入的参数。
- 在 C++ 中，`**void f1()**` 的语义等同于 `**void f1(void)**`，表示函数没有形参。
- **注意**：在 C 中，`**void f1()**` 表示函数可以接受任意数量、任意类型的参数（旧式语法）。
**2.** `**void f2(void)**`**（显式形参列表为空）**
- 在 C 和 C++ 中，`**void f2(void)**` 明确表示函数没有参数。
- 编译器会强制检查，调用时不能传递任何参数。
- `**void**` 是一个占位符，用来明确指定函数没有参数。
---
### 局部对象
  
**1. 名字的作用域（Scope of a Name）**
**名字的作用域**是指程序文本中一个名字（如变量名、函数名、类名等）**可见**和**可以访问**的范围。
**作用域分类**
1. **块作用域（Block Scope）**：
    - 定义在代码块 `**{}**` 内的名字，其作用域从定义处到代码块结束。
    - 例如，局部变量和函数参数。
2. **全局作用域（Global Scope）**：
    - 定义在所有函数或类外部的名字，其作用域是整个程序。
    - 全局名字在文件中可见，但如果跨文件使用，则需要 `**extern**` 声明。
3. **类作用域（Class Scope）**：
    - 类成员（包括成员变量和成员函数）的作用域是类定义的范围内。
    - 通过作用域解析运算符 `**::**` 可以访问类成员。
4. **命名空间作用域（Namespace Scope）**：
    - 命名空间内定义的名字的作用域是整个命名空间。
    - 使用 `**using**` 或显式命名空间修饰符访问。
5. **文件作用域（File Scope）**：
    - 使用 `**static**` 修饰的名字，其作用域限定在当前文件内。
  
**2. 对象的生命周期（Lifetime of an Object）**
**对象的生命周期**是指程序运行过程中，**对象从被创建到被销毁的时间段**。
**生命周期分类**
1. **自动存储周期（Automatic Storage Duration）**：
    - 局部变量在进入其所在的代码块时创建，在代码块结束时销毁。
    - 生命周期受作用域的限制。
2. **静态存储周期（Static Storage Duration）**：
    - 全局变量、`**static**` 变量的生命周期是整个程序的运行时间。
    - 它们在程序开始时创建，在程序结束时销毁。
3. **动态存储周期（Dynamic Storage Duration）**：
    - 使用 `**new**` 或 `**malloc**` 动态分配的对象，其生命周期由程序控制。
    - 必须显式释放，否则会导致内存泄漏。
4. **线程存储周期（Thread Storage Duration）**：
    - 用 `**thread_local**` 修饰的变量，其生命周期贯穿线程的执行时间，线程结束时销毁。
  
作用域和生命周期对比:
|                  |                                        |                                                                        |
| ---------------- | -------------------------------------- | ---------------------------------------------------------------------- |
| **属性**         | **作用域**                             | **生命周期**                                                           |
| **定义**         | 程序文本中名字可见的范围               | 程序执行过程中对象存在的时间段                                         |
| **受什么控制**   | 由语法块、类、命名空间或全局定义等决定 | 由存储方式（自动、静态、动态、线程）决定                               |
| **结束的时间**   | 名字超出作用域后不可见                 | 对象超出生命周期后被销毁                                               |
| **是否一定相关** | 名字的作用域和对象的生命周期可以不同   | 生命周期独立于名字的作用域，例如动态分配的对象可以超出作用域后依然存在 |
---
### 函数声明
在 C++ 中，**变量**和**函数**通常采用“**在头文件中声明，在源文件中定义**”的方式进行组织。这种做法不仅是最佳实践，还能有效避免许多潜在问题（如重复定义、符号冲突等）。
---
### 分离式编译
**分离式编译**是 C++ 提供的一种机制，允许将程序拆分为多个源文件（通常是 `**.cpp**` 文件），每个源文件可以独立编译，最后在链接阶段将它们组合成一个完整的可执行程序。
**1. 文件分工**
- **头文件（Header Files，**`**.h**`**）**：
    - 包含变量、函数、类等的**声明**。
    - 提供模块的接口，使其他源文件可以使用这些声明。
- **源文件（Source Files，**`**.cpp**`**）**：
    - 包含头文件中声明的函数或类的**定义**。
    - 具体实现模块的逻辑。
- **主程序文件（Main Program File，通常也是** `**.cpp**`**）**：
    - 包含程序入口点（`**main()**`）。
    - 调用其他模块的接口，完成程序的整体功能。
**2. 分离式编译的流程**
1. **拆分代码**：
    - 将逻辑相关的代码放到不同的源文件中，并通过头文件声明接口。
2. **独立编译**：
    - 每个 `**.cpp**` 文件单独编译成目标文件（`**.o**` 或 `**.obj**`）。
3. **链接目标文件**：
    - 将所有目标文件和必要的库文件链接成最终的可执行文件。
[[示例-分离式编译]]
  
---
# 参数传递
1. **什么是实参（Actual Parameter）？**
    - **实参**是调用函数时传递给函数的具体值或变量。
    - 实参用于初始化形参。
    - 实参的生命周期在函数调用时开始，在函数调用结束后结束。
**2. 什么是形参（Formal Parameter）？**
- **形参**是函数定义时声明的变量，用于接收实参的值。
- 形参是函数内部的局部变量，其生命周期在函数被调用时开始，函数结束时销毁。
- 形参是对实参值的拷贝（值传递）或对实参的引用（引用传递）。
1. **函数参数**的处理取决于是否使用指针、引用或者值传递。这影响了传递的是原始数据还是副本：
    - **值传递**：传递的是实参的**副本**。
    - **引用传递**：传递的是实参的别名，不是副本。
    - **指针传递**：传递的是指针的**副本**，但可以通过指针操作指向的原始对象。
---
**在函数中使用引用形参:**
在 C++ 中，**引用形参**允许通过引用传递参数，从而避免不必要的拷贝操作，提高性能。然而，如果函数不需要修改引用参数的值，**最好将引用参数声明为常量引用（**`**const &**`**）**。这样可以提高代码的**安全性**和**可读性**。

```
void func(const std::string& param);
```

**在函数传参中的顶层const:**
在 C++ 中，当用**实参初始化形参**时，形参的**顶层** `**const**` 会被忽略。这是因为顶层 `**const**` 只影响变量本身是否可修改，而不会影响实参传递和形参的初始化过程。
  
**尽量用常量引用定义不会改变的形参:**
|                                            |                                                  |
| ------------------------------------------ | ------------------------------------------------ |
| **普通引用（**`**T&**`**）**               | **常量引用（**`**const T&**`**）**               |
| 函数需要修改传入的参数时使用。             | 函数不需要修改参数值时使用。                     |
| 只能绑定到非常量左值（`**T**` 类型对象）。 | 可以绑定到常量对象、字面值和需要类型转换的对象。 |
| 提供修改能力，但调用者需谨慎，避免误导。   | 提高兼容性，明确表明函数不会修改参数的值。       |
---
### 数组形参
- 当数组作为形参传递时，数组会**退化为指针**，传递的是数组的首地址。
- 数组的大小信息不会被隐式传递给函数，必须显式传递或通过其他手段管理。
**常见的管理方式**
**用特殊结束符表示数组结束**
**显式传递数组大小**
最简单的方式是通过形参显式传递数组的大小。
**明确指针边界**
如果必须使用原生指针作为形参，可以通过传递指针的范围（起始指针和结束指针）来管理。
**使用模板推导数组大小**
可以使用模板函数让编译器推导数组的大小。
---
### main:处理命令行选项
`int main(int argc, char *argv[])`
- `**argc**`：一个整数，表示命令行参数的数量。包括程序本身的名字。
- `**argv**`：一个数组，它的元素是指向 C 风格字符串（即以空字符 `\0` 结尾的字符数组）的指针。这个数组包含了传递给程序的所有命令行参数，其中 `argv[0]` 通常是程序的名称。
`int main(int argc, char **argv)`
- `**argc**` 和 `**argv**` 的含义与上面一样，区别仅在于 `argv` 的声明方式。
- 这两者的本质是相同的，只是写法不同。
在这种形式中，`argv` 是一个指向 `char*` 的指针，等价于 `char *argv[]`。即：
- `argv` 是一个指向字符指针的指针（`char**`），它指向一个字符串数组。
- `argv[i]` 仍然是指向第 `i` 个命令行参数的字符指针。
---
### 含有可变形参的函数
如果函数的实参数量未知，但所有实参的类型相同，使用初始化列表或可变参数模板都可以实现这一功能。
**1. 使用 初始化列表（**`**std::initializer_list**`**）**
C++11 引入了 `std::initializer_list`，它允许函数接收一个类型相同的参数列表，可以在函数调用时使用大括号 `{}` 来传递一系列元素。

```
\#include <iostream>
\#include <initializer_list>
void print_numbers(std::initializer_list<int> numbers) {
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}
int main() {
    print_numbers({1, 2, 3, 4, 5});  // 传递一个初始化列表
    return 0;
}
```

2. 使用 **可变参数模板**（`template <typename... Args>`）
另一种方式是使用 **可变参数模板**，它允许函数接受一个不定数量的实参，而这些实参的类型可以相同或不同。通过可变参数模板，你可以构造一个处理任意数量和类型参数的函数。

```
\#include <iostream>
// 可变参数模板函数
template <typename... Args>
void print_numbers(Args... args) {
    // 展开参数包，逐个打印
    (std::cout << args << " ", ...);
    std::cout << std::endl;
}
int main() {
    print_numbers(1, 2, 3, 4, 5);  // 传递多个参数
    return 0;
}
```

- `template <typename... Args>` 定义了一个可变参数模板，`Args...` 是一个类型参数包，可以匹配任意数量的类型相同或不同的参数。
- 在函数体内，使用了折叠表达式 `(std::cout << args << " ", ...)`，这会展开 `args...`，依次打印所有传入的参数。
- `print_numbers` 可以接收任意数量的实参，并且都将按顺序输出。
---
# 返回类型
在 C++ 中，返回一个值时的方式和初始化一个变量或形参的方式非常相似。当函数返回值时，实际上是将返回的值用于初始化调用点的一个临时变量。这个临时变量承载了函数的返回结果。
- 不要返回局部对象的引用或指针
### 不要返回局部对象的引用或指针
1. `**std::string manip()**`
    - 返回值是一个 `std::string` 对象。
    - 调用者会获得该对象的**副本**（通过拷贝或移动）。
2. `**const std::string& manip()**`
    - 返回值是一个对 `std::string` 对象的**常量引用**。
    - 该对象的生命周期必须在函数返回后仍然有效，否则会导致未定义行为。
    - 返回的对象不能被调用者修改（因为是 `const` 引用）。
### 引用返回左值
可以像使用其他左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值 .例如返回数组str[idx],可以直接对str的下标idx元素操作
### 列表初始化返回值
C++11 引入了一项新特性，允许函数返回一个**花括号包围的值的列表**，即使用 **初始化列表（**`**std::initializer_list**`**）**作为返回值。这个特性使得返回一组值更加简洁直观。
`std::initializer_list` 的元素生命周期由编译器管理，返回的列表在调用点是安全的。
`**std::initializer_list**` **是只读的：**
- 返回的 `std::initializer_list` 对象是不可修改的，无法对其元素进行更改。
- 如果需要修改元素，应该选择使用支持可变操作的容器类型（如 `std::vector`
|                         |                                       |                            |
| ----------------------- | ------------------------------------- | -------------------------- |
| 返回类型                | 示例代码                              | 适用场景                   |
| `std::initializer_list` | `return {1, 2, 3};`                   | 返回不可变的值列表         |
| `std::vector`           | `return {1, 2, 3};`                   | 返回可变大小的动态值列表   |
| `std::array`            | `return std::array<int, 3>{1, 2, 3};` | 返回固定大小的不可变值列表 |
---
## 返回数组指针
|                          |                                                                    |                                                  |
| ------------------------ | ------------------------------------------------------------------ | ------------------------------------------------ |
| 方法                     | 优点                                                               | 缺点                                             |
| **类型别名**             | 简化复杂声明，提高代码可读性。                                     | 定义类型别名需要额外步骤。                       |
| **直接声明返回数组指针** | 无需额外定义类型，直接标准语法实现。                               | 声明复杂，可读性较差。                           |
| **尾置返回类型**         | C++11 引入，声明简洁，可与模板结合使用，适合现代 C++。             | 需要熟悉尾置返回类型的语法。                     |
| `**decltype**`           | 自动推导类型，减少编写复杂类型声明的需求，适合模板和动态类型场景。 | 对初学者可能不够直观，需要配合模板或表达式使用。 |
### 类型别名

```
typedef elementType (*AliasName)[size];  // 通过 typedef 定义别名
using AliasName = elementType (*)[size];  // 通过 using 定义别名
```

### 直接声明返回数组指针
- 数组指针的声明形式：`type (*functionName())[size]`。
    - 这里的具体解释是定义了一个大小为size的type类型数组, 数组由一个指针通过解引用来访问, `functionName()`的返回值就是这个指针
- 返回的数组必须保证生命周期有效，例如使用静态分配或动态分配。
### 尾置返回类型（Trailing Return Type）
- 尾置返回类型通过 `auto` 和 `>` 声明。
- 声明格式：`auto functionName() -> returnType;`
- 编译器会在尾部解析返回的数组指针类型。
### 使用 `decltype`
- `decltype` 自动推导表达式的类型，用于函数返回值时特别适合。
- 返回数组指针的函数可利用**已有数组变量**的类型进行推导。
### **推荐做法**
1. **现代 C++（C++11 及以上）：**
    - 优先使用 **尾置返回类型** 或 `**decltype**`，代码简洁且符合现代风格。
2. **传统 C++（C++03）：**
    - 使用 **类型别名** 或直接声明返回数组指针。
3. **特殊场景：**
    - 如果函数返回多个数组或涉及模板编程，推荐使用尾置返回类型。
---
# 函数重载
### 函数重载判断两个形参的类型是否相异
最关键的是判断在用实参初始化形参时, 形参只要类型,数量不一致,便是可以重载的.
1. **类型不同**
- 两个形参的类型必须不同，类型的区分包括基本类型、引用类型、指针类型等
2. **顶层** `**const**` **不影响重载**
- 顶层 `const` 是指对参数本身的 `const` 修饰，在判断函数是否重载时会被忽略。
- 举例：
    
    ```C++
    void func(int a);
    void func(const int a); // 顶层 const 被忽略，与上一函数冲突，非法
    ```
    
3. **底层** `**const**` **影响重载**
- 底层 `const` 是指修饰指针指向的对象，在重载判断时是有效的。
- 举例：
    
    ```C++
    void func(int* a);           // 指针类型参数
    void func(const int* a);     // 指向 const 的指针类型，与上一函数不同，合法重载
    ```
    
4. **引用类型的区分**
- 引用和非引用、常量引用和非常量引用会被认为是不同类型。**主要是因为传入引用参数时, 直接传入别名,而不是副本.**
- 举例：
    
    ```C++
    void func(int& a);           // 非常量引用
    void func(const int& a);     // 常量引用，与上一函数不同，合法重载
    ```
    
5. **参数数量不同**
- 只要参数数量不同，即使类型相同，也可以合法重载。
- 举例：
    
    ```C++
    void func(int a);            // 单个参数
    void func(int a, int b);     // 两个参数，与上一函数不同，合法重载
    ```
    
6. **参数顺序不同**
- 如果形参的类型相同但顺序不同，可以合法重载。
- 举例：
    
    ```C++
    void func(int a, double b);  // 参数顺序：int, double
    void func(double a, int b);  // 参数顺序：double, int，与上一函数不同，合法重载
    ```
    
7. **默认参数不能区分重载**
- 默认参数不会被用于区分函数重载。
- 举例：
    
    ```C++
    void func(int a = 0);        // 默认参数
    void func();                 // 编译器无法区分，非法重载
    ```
    
1. **返回值类型不同不能构成重载**
- 函数调用通过函数名和参数列表的匹配来解析调用的具体函数，而返回值类型是函数调用后才确定的，无法在调用时参与解析。
---
## 重载和作用域
在 C++ 中，**作用域（scope）** 和 **重载（overloading）** 是两个重要概念，它们在程序设计中经常结合使用。然而，作用域和重载的结合有一些规则和限制，特别是在作用域嵌套时：
### 1. 内层作用域会隐藏外层作用域的同名函数
如果在内层作用域中声明了一个与外层作用域同名的实体，无论是变量还是函数，内层的声明都会 **隐藏外层作用域的同名实体**。这种行为是作用域规则的一部分，与是否支持重载无关。
### **2. 为什么在不同作用域中无法重载函数名？**
重载（overloading）发生在同一个作用域中，C++ 编译器会根据参数列表的差异来区分同名的函数。如果函数在不同作用域中定义，则它们属于不同的上下文，编译器不认为它们是同一个集合中的重载。
### **3. 如何解决作用域与重载的冲突？**
- **显式使用外层作用域的函数**
    - 通过作用域运算符（`::`）可以显式调用外层作用域的函数。
    - `::func();`
- **使用** `**using**` **声明将外层函数引入到内层作用域**
    - 可以通过 `using` 声明将外层作用域中的函数引入内层作用域，从而实现重载。
    - `using ::func; func();`
---
# 特殊用途语言特性
## 内联函数
**传统调用**：
- 参数入栈。
- 跳转到函数地址。
- 执行函数代码。
- 返回调用点。
将函数指定为内联函数 (inline), 通常就是将它在每个调用点上“内联地”展开。 避免了传统函数调用的栈操作开销.
## constexpr 函数
在 C++ 中，`constexpr` 函数是一种可以在 **编译期** 计算其结果的函数，用于支持常量表达式。与普通函数类似，但有特定的限制和用途。
### `**constexpr**` **函数的特点**
1. **编译期求值**：
    - 如果 `constexpr` 函数的所有实参都是常量表达式，则函数本身会在编译期执行，生成一个常量结果。
2. **运行时调用**：
    - `constexpr` 函数也可以在运行时调用。如果传入的实参不是常量表达式，则会在运行时求值。
3. **限制**：
    - 返回类型及所有形参的类型必须是 **字面值类型**。字面值类型包括内置类型（如 `int`、`double`）以及字面值类型的类（具有 constexpr 构造函数的类）
    - 函数体必须是一个单一的 `return` 语句，且不能包含复杂的逻辑（如循环或条件）。
### 把内联函数和 constexpr 函数放在头文件内
---
## 调试帮助
### cassert预处理宏
assert 是一种预处理宏( preprocessor marco)。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数.

```
\#include <cassert>
assert(expression);
```

`**expression**`：任意的布尔表达式。
- 如果 `expression` 的值为 `true`，程序继续执行。
- 如果 `expression` 的值为 `false`，程序会打印错误信息，并终止执行。
`assert` 通常只在调试模式下启用，在发布版本中禁用（通过预处理宏 `NDEBUG` 控制）。
### NDEBUG 预处理变量
如果 **定义了** `NDEBUG`，`assert` 宏会被替换为空操作，运行时不会进行任何检查。  
**如何定义** `**NDEBUG**`
- 可以在代码中通过 `#define NDEBUG` 定义 `NDEBUG`。
- 可以在编译时通过编译器选项 `-DNDEBUG` 定义 `NDEBUG`。
通过`#ifndef NDEBUG` 来自定义调试信息,C++编译器提供了一些程序调试的名字,可以直接通过cout打印:
|            |                                              |              |                |
| ---------- | -------------------------------------------- | ------------ | -------------- |
| **宏名称** | **含义**                                     | **类型**     | **示例值**     |
| `__FILE__` | 当前文件的文件名。                           | 字符串字面值 | `"main.cpp"`   |
| `__LINE__` | 当前文件中的行号。                           | 整型字面值   | `42`           |
| `__TIME__` | 当前文件编译的时间（精确到秒）。             | 字符串字面值 | `"12:34:56"`   |
| `__DATE__` | 当前文件编译的日期（格式为 "MMM DD YYYY"）。 | 字符串字面值 | `"Dec 8 2024"` |
| `__func__` | 当前函数的名称（C++11 起支持）。             | 字符串字面值 | `"main"`       |
# 函数匹配
函数匹配出现在传入参数类型与定义参数类型不一致, 但是可以通过实参类型转换得到函数希望的参数,进而匹配函数重载的情况.
---
# 函数指针
在 C++ 中，函数指针是一种指针类型，它指向的是函数而非对象。与普通指针类似，函数指针也有类型，但这个类型由函数的 **返回类型** 和 **形参列表** 决定，而与函数的名字无关。
`返回类型 (*指针变量名)(形参列表);`
函数名本质上是指向函数的地址，因此可以直接赋值给函数指针。

```
int add(int a, int b) {
    return a + b;
}
// 定义一个指向返回 int、接受两个 int 参数的函数的指针
int (*func_ptr)(int, int) = add;
int main() {
    // 通过函数指针调用函数
    int result = func_ptr(10, 20);  // 等价于 add(10, 20)
    std::cout << result << std::endl;  // 输出：30
    return 0;
}
```

### **函数指针的应用**

```
int add(int a, int b) {
    return a + b;
}
int multiply(int a, int b) {
    return a * b;
}
int subtract(int a, int b) {
    return a - b;
}
```

**1. 作为函数参数**
函数指针常用于回调机制，可以将一个函数指针作为参数传递给另一个函数。

```
// 接收函数指针作为参数
int compute(int x, int y, int (*op)(int, int)) {
    return op(x, y);  // 调用函数指针指向的函数
}
```

**2. 作为返回值**
函数可以返回一个函数指针，用于动态选择操作。

```
// 返回函数指针
int (*getOperation(char op))(int, int) {
    if (op == '+') return add;
    if (op == '*') return multiply;
    return nullptr;
}
//1. getOperation是一个函数
//2. getOperation解引用后得到了一个函数类型,因此getOperation的返回值是一个指针
//3. 指针类型有形参列表,因此指针是函数指针,并且所指函数返回类型是int
```

```
//使用auto结和尾指返回类型来返回函数指针
auto getOperation(char op) -> int (*)(int, int);
auto getOperation(char op) -> int (*)(int, int){
    if (op == '+') {
        return add;
    } else if (op == '*') {
        return multiply;
    } else {
        return nullptr;
    }
}
```

```
//通过decltype(fun) 可以获得fun的函数类型, 要获得函数指针还需要加上*
decltype(add) *getAddFunction(char op) {
    if (op == '+') {
        return add;
    }
}
```

```
//位置返回类型和decltype结和
auto getAddFunction() -> decltype(add) * {
    if (op == '+') {
        return add;
    }
}
```

**3. 用于数组**
函数指针可以用于管理一组函数，例如用函数指针数组实现简单的调度。

```
int (*operations[])(int, int) = {add, multiply, subtract};
```

**4. 函数指针和重载函数**
当指针指向重载函数时，必须明确指定函数的类型（使用 `static_cast` 或手动选择），否则会导致编译错误。
**5. 函数指针与** `**std::function**`
C++11 引入了 `std::function`，可以作为函数指针的更强大的替代品。它支持多种可调用对象（普通函数、函数指针、**Lambda 表达式**等）。

```
\#include <iostream>
\#include <functional>  // 引入 std::function
int add(int a, int b) {
    return a + b;
}
int main() {
    std::function<int(int, int)> func = add;  // 用 std::function 封装函数指针
    std::function<int(int, int)> func2 = [&](int a,int b){
	    return a+b}
    std::cout << "Sum: " << func(10, 20) << std::endl;  // 输出：Sum: 30
    std::cout << "Sum: " << func2(10, 20) << std::endl;  // 输出：Sum: 30
    return 0;
}
```

---
[[C++ primer]]
