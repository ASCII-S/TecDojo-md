[C++primer](C++primer.md)
---
# 动态内存

**从物理上解释内存的分配方式**
内存的分配方式主要有以下几种：

1. **静态分配**：
   - 在编译时分配内存，分配的内存大小在程序运行期间不可改变。静态分配的内存通常用于全局变量和静态变量。

2. **栈分配**：
   - 在函数调用时分配内存，内存的生命周期与函数的调用和返回相同。栈分配的内存用于局部变量，分配和释放速度快，但内存大小有限。

3. **堆分配**：
   - 在运行时动态分配内存，程序可以根据需要请求任意大小的内存。堆分配的内存需要手动管理（使用 `new` 和 `delete`），适合需要动态调整大小的情况。

4. **内存映射**：
   - 通过操作系统提供的内存映射功能，将文件或设备映射到内存中，允许程序像访问内存一样访问文件内容。这种方式适合处理大文件或共享内存。

5. **共享内存**：
   - 允许多个进程访问同一块内存区域，适合进程间通信（IPC）。共享内存的管理通常由操作系统负责。

每种内存分配方式都有其适用场景和优缺点，开发者需要根据具体需求选择合适的方式。

---
# 动态内存与智能指针

**动态内存的管理**
- 动态内存的管理是通过 `new` 和 `delete` 操作符来实现的。
- `new` 操作符用于在运行时动态分配内存，`delete` 操作符用于释放动态分配的内存。
- 动态内存的分配和释放需要开发者手动管理，否则会导致**内存泄漏**。

**智能指针**
- 智能指针是一种自动管理动态内存的工具，由标准库`<memory>`提供，它可以在对象的生命周期结束时**自动释放**动态分配的内存。
- 智能指针通过**引用计数**或**弱引用**等方式来管理动态内存，避免了手动管理内存的复杂性。
  - 引用计数：智能指针内部维护一个计数器，当有新的指针指向对象时，计数器加一，当指针被销毁时，计数器减一，当计数器为零时，对象才会被释放。
  - 弱引用：弱引用不会增加对象的引用计数，当对象被销毁时，弱引用会自动变为无效。
- 智能指针可以避免内存泄漏和悬挂指针等问题。
  - 内存泄漏：内存泄漏是指程序在运行过程中分配的内存没有被及时释放，导致内存占用不断增加，最终可能导致程序崩溃。
  - 悬挂指针：悬挂指针是指指针指向的内存已经被释放，但指针仍然存在，导致程序访问非法内存，可能会导致程序崩溃。

**智能指针的类型**
- `std::shared_ptr`：共享指针，允许多个指针指向同一个对象，当最后一个指针被销毁时，对象才会被释放。
- `std::unique_ptr`：独有指针，独有指针只能有一个指向对象，当指针被销毁时，对象才会被释放。
- `std::weak_ptr`：弱指针，弱指针不会增加对象的引用计数，当对象被销毁时，弱指针会自动变为无效。

## shared_ptr类

### **shared_ptr的构造函数**

```
// 默认初始化，p为空
shared_ptr<T> p;

// 拷贝构造
shared_ptr<T> p(p2);

// 移动构造
shared_ptr<T> p(move(p2));

// 通过new分配内存
shared_ptr<T> p(new T);
// 使用make_shared
shared_ptr<T> p = make_shared<T>(args);

```

### **智能指针公共的操作**

```
shared_ptr<T> sp; //空智能指针，可以指向类型为T的对象
unique_ptr<T> up; //空智能指针，可以指向类型为T的对象

*p //解引用，返回p所指向的对象
p.get() //返回p中保存的指针
swap(p, q) //交换p和q中的指针
p.swap(q) //交换p和q中的指针
```

### **shared_ptr独有的操作**

```
shared_ptr<T> q = make_shared<T>(args) //make_shared函数返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化对象
shared_ptr<T> p(q) //p是q的拷贝，q必须能转换为T*类型

p = q //p和q都是shared_ptr。这个操作会将p原来管理的对象都释放，然后p管理q所指向的对象
    // 调用了shared_ptr的拷贝复制运算符:std::shared_ptr<T>& operator=(const std::shared_ptr<T>& r);
    // 这个运算符会递减p的引用计数，然后递增q的引用计数，如果p的引用计数变为0，则释放p所指向的对象
p.unique() //如果p.use_count()为1，返回true，否则返回false
p.use_count() //返回与p共享对象的智能指针数量，很慢，主要用于调试
```

### **make_shared函数**
- make_shared函数是shared_ptr的工厂函数，用于创建一个shared_ptr对象，并自动管理动态分配的内存。

```
shared_ptr<T> p = make_shared<T>() //返回一个空的shared_ptr，指向一个动态分配的类型为T的对象
shared_ptr<T> p = make_shared<T>(args) //返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化对象
```

### **shared_ptr的拷贝和赋值**
- 引用计数递增情况
  - 拷贝一个shared_ptr
  - 赋值一个shared_ptr
  - 将shared_ptr作为实参传递给一个函数
  - 将shared_ptr作为函数的返回值
- 引用计数递减情况
  - 一个shared_ptr被销毁
  - 一个shared_ptr q被赋值为另一个shared_ptr p,则q的引用计数递增，p的引用计数递减
  - 一个shared_ptr被赋值为空
- 引用计数变为0时，对象被释放

### **shared_ptr的析构函数**
- 当一个shared_ptr被销毁时，它会自动释放其所管理的对象，并递减引用计数。
- 当引用计数变为0时，对象被释放。
> 注意:
> 如果你将 shared_ptr 存放于一个容器中，而后不再需要全部元素，而只需要其中一部分，记得使用 erase 删除不再需要的元素，以避免内存泄漏。

### **使用动态生存期的类**
- 程序不知道自己需要使用多少对象
- 程序不知道所需对象的准确类型
- 程序需要在多个对象间**共享数据**

### **动态生存期的类**
- 动态生存期的类通常需要使用shared_ptr来管理其对象，以避免内存泄漏。
- 动态生存期的类通常需要使用new和delete来管理其对象，以避免悬挂指针等问题。

### **StrBlob程序**
- 程序需要实现多个类对同一个vector<string>对象的共享。
- 实现方法为:
  - 在类StrBlob中使用shared_ptr来管理vector<string>对象
  - 通过StrBlobPtr类来访问StrBlob中的vector<string>对象
  - StrBlobPtr类中使用weak_ptr来获取StrBlob中的vector<string>对象，避免StrBlobPtr类和StrBlob类之间循环引用

## 直接管理内存
C++中提供了new和delete操作符来管理动态内存。

### **new动态内存分配**
- new操作符用于在运行时动态分配内存，返回一个指向新分配内存的指针。
  - 由于在自由空间(堆)中分配的内存是匿名的，所以new操作符返回的指针也必须是一个指向该对象的指针。
- 默认情况下,动态分配的对象是默认初始化的。
  - 如果对内置类型进行动态内存分配，则分配的内存会被初始化为0，这是这一种未定义行为。
  - 如果对类类型进行动态内存分配，则类类型会自动调用其默认构造函数进行初始化。

```
int *p1 = new int; // 默认初始化,*p1未定义
int *p2 = new int(); // 初始化为0,*p2为0
```

> 注意:
> 建议在动态内存分配时就进行初始化，避免未定义行为。

### **使用auto简化new动态内存分配**
- 提供括号初始化器后，可以使用auto自动化推导动态内存分配的类型。

```
auto p = new auto(obj);
```

> 📝auto 与花括号初始化注意: 
> ```C++
> auto x = {1, 2, 3}; 推导为 initializer_list<int> ✅
> auto x{1, 2, 3}; 非法，必须只含一个元素 ❌
> new auto({1, 2, 3}) 不合法，不能这样推导类型 ❌
> 若需指针，写成 new std::initializer_list<int>({...}) ✅
> ```

### **动态分配const对象**
- 一个动态分配的const对象必须使用new const T()来初始化。
  - 对于定义了默认构造函数的类类型，const T()会调用默认构造函数初始化。

```
const int *pci = new const int(1024);
```

### **内存耗尽**
- 如果new失败，会抛出std::bad_alloc异常。
- 定位new表达式：可以使用nothrow版本new，如果new失败，返回空指针。

```
#include <new> // 包含new的头文件,bad_alloc和nothrow定义在此
int *p1 = new int(42); // 如果new失败，会抛出std::bad_alloc异常
int *p2 = new (nothrow) int(42); // 如果new失败，返回空指针
```

### **释放动态内存**

- delete操作符会销毁指针所指向的对象，并释放对应内存，并将其返回给自由空间。

```
delete p; // 释放p所指向的内存
```

- 传递给delete的指针必须指向动态内存，或者是一个空指针。
- 相同指针多次delete会引发未定义行为。

### **动态对象的生命周期**
- 由shared_ptr管理的对象，在最后一个shared_ptr被销毁时，对象才会被释放。
- 由内置指针管理(new/delete)的对象，在delete时，对象才会被释放。

### **delete产生的空悬指针**
- 空悬指针通常是由于delete操作符释放了指针所指向的内存，导致指针指向的内存已经被释放，但指针仍然存在，导致程序访问非法内存，可能会导致程序崩溃。
- 可以在指针即将离开其作用域之前，将指针赋值为nullptr，避免空悬指针。
  - 由于动态内存可能被**多个指针**管理，所以即使将指针赋值为nullptr，也不能保证其他指针不会访问到已经释放的内存。

## shared_ptr和new结合使用

- 智能指针的构造函数是[[notes/explicit.md]]的，所以不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化方式。

```
shared_ptr<int> p1 = new int(1024); // 错误，不能隐式转换
shared_ptr<int> p2(new int(1024)); // 正确，直接初始化
```

**shared_ptr的方法**

```
T* p = new T; //p为内置指针
shared_ptr<T> p(q) //p管理内置指针q所指向的对象，q必须能转换为T*类型
shared_ptr<T> p(q,d) //p管理内置指针q所指向的对象，q必须能转换为T*类型，d是一个可调用对象，当p的引用计数为0时，会调用d来释放p所指向的对象
p.reset() //如果p是唯一指向其对象的shared_ptr，reset会释放此对象，然后让p为空
p.reset(q) //如果p是唯一指向其对象的shared_ptr，reset会释放此对象，然后让p指向q
p.reset(q,d) //如果p是唯一指向其对象的shared_ptr，reset会使用可调用对象d来释放此对象，然后让p指向q
```

### **shared_ptr易错点**

- 不要混合使用普通指针和智能指针

```
void process(shared_ptr<int> ptr)
{
// 使用 ptr
}

shared_ptr<int> p(new int(42)); 
process(p)

int *x(new int(1024));
process(shared_ptr<int>(x));
```

- 不要使用 get 初始化 另一个智能指针或为智能指针赋值
  - get是shared_ptr的成员函数，返回一个内置指针，指向智能指针管理的对象。
  - get得到的指针无法执行delete操作。
  - 但是这个内置指针不是shared_ptr的一部分。如果用这个内置指针初始化另一个智能指针，会导致两个智能指针管理同一个对象，当其中一个智能指针被销毁时，对象会被释放，导致另一个智能指针变成空悬指针。
  - ```C++
    shared_ptr<int> p(new int(42));
    int *q = p.get();
    {
        // 使用 q
        shared_ptr<int> p2(q);
    }// 离开作用域，p2被销毁，q被销毁，指向的内存被释放
    int foo = *p; // 访问非法内存，p为空悬指针
    ```

### **reset函数**
- reset函数是shared_ptr的成员函数，用于重置智能指针。
- 如果reset传递一个新指针，则智能指针会管理这个新指针，并替换旧指针。
- 如果reset不传递参数，则智能指针会被置空。
  - ```C++
    shared_ptr<int> p(new int(42));
    p.reset(); // 释放p所指向的对象，p被置空
    p.reset(new int(1024)); // 释放p所指向的对象，p管理新的对象
    ```

## 智能指针和异常

### **使用智能指针确保异常安全**
- 直接管理内存时，发生异常，内存不会被释放。
- 使用智能指针管理动态内存，可以确保在异常发生时，动态内存会被正确释放。

### **智能指针和哑类**
- 哑类是指没有自定义的析构函数、拷贝构造函数和赋值运算符的类。
- 哑类不能直接管理动态内存，因为动态内存需要手动释放，而哑类没有自定义的析构函数。
- 智能指针有析构函数，可以自动释放动态内存。

### **自定义shared_ptr的删除器**
- 智能指针的删除器是一个可调用对象，当智能指针被销毁时，会调用这个可调用对象来释放动态内存。

```
shared_ptr<T> p(new T, [](T *p) { delete p; });
```

## unique_ptr

相较于shared_ptr，unique_ptr是独有指针，某时某刻只能有一个指针指向一个给定的对象，当指针被销毁时，对象也会被释放。

- unique_ptr拥有它指向的对象,因此不支持拷贝和赋值。

### **unique_ptr操作**

```
unique_ptr<T> u1; //空unique_ptr，可以指向类型为T的对象
unique_ptr<T> u2(p) //u2是p的拷贝，p必须能转换为T*类型
unique_ptr<T> u(move(p)) //u是p的移动，p被置空
u = nullptr //u被置空
u.release() //u放弃对指针的控制权，返回指针，并将u置空
u.reset() //释放u所指向的对象，并置空u
u.reset(p) //释放u所指向的对象，并让u指向p
u.reset(nullptr) //释放u所指向的对象，并置空u
```

### **unique_ptr的传递与返回**
- unique_ptr的拷贝构造函数和赋值运算符被声明成delete的，所以不能将一个unique_ptr赋值给另一个unique_ptr，必须使用移动语义。
- 一个例外是，当函数返回一个unique_ptr时，会自动进行移动语义。这是因为在函数返回时，返回值是一个临时对象（纯右值），编译器会使用移动构造函数将这个临时对象的资源所有权转移给调用者。

### **unique_ptr的删除器**
- unique_ptr的删除器是一个可调用对象，当unique_ptr被销毁时，会调用这个可调用对象来释放动态内存。

```
// D 是删除器的类型，删除器是一个可调用对象，当 unique_ptr 被销毁时，会调用这个删除器来释放所管理的对象的内存。默认情况下，D 是 std::default_delete<T>，它会使用 delete 来释放内存。
unique_ptr<T, D> u(new T, [](T *p) { delete p; });
```

## weak_ptr

weak_ptr是一种弱引用，它不会增加shared_ptr的引用计数，当对象被销毁时，weak_ptr会自动变为无效。

### **weak_ptr的操作**

```
weak_ptr<T> w; //空weak_ptr，可以指向类型为T的对象
shared_ptr<T> sp = make_shared<T>(args);
weak_ptr<T> w(sp) //w是sp的拷贝，sp必须能转换为T*类型
```

### **通过weak_ptr访问对象**
- 通过weak_ptr访问对象时，由于无法确定对象是否存在，需要先调用lock函数，将weak_ptr转换为shared_ptr。
- lock() 会尝试将 weak_ptr 提升为 shared_ptr：
  - 成功：对象仍存在，返回一个有效的 shared_ptr，引用计数 +1。
  - 失败：对象已销毁，返回空的 shared_ptr（等价于 nullptr）

```
if (shared_ptr<T> sp = w.lock()) {
    // 使用 sp
} else {
    // 对象已销毁
}
```

---
# 动态数组

为了支持一次为多个对象分配内存，C++提供了两种一次分配一个对象数组的方法。
- 使用新形式的new和delete分配和释放动态数组
- 使用标准库容器allocator分配和释放动态数组

## new和数组

### **如何使用new分配数组**
- 通过在类型名后面添加一对空括号来分配一个数组
- 返回的指针是一个指向数组首元素的指针

```
int *p = new int[10]; // 分配一个包含10个int的数组
```

### **如何使用delete释放数组**
- 通过在指针前面添加一对空括号来释放一个数组
- 空方括号指示编译器，应该释放整个数组

```
delete[] p; // 释放p所指向的数组
```

### **初始化动态分配数组**
- 默认情况下，动态分配的数组会被默认初始化。
- 如果需要初始化数组，可以通过在类型名后面添加一对圆括号或花括号来初始化。

```
int *p = new int[10](); // 分配一个包含10个int的数组，并初始化为0
int *p = new int[10]{0,1,2,3,4,5,6,7,8,9}; // 分配一个包含10个int的数组，并初始化为0,1,2,3,4,5,6,7,8,9
```

### **动态数组初始化的边界处理**
- 如果初始化列表的元素个数小于数组的大小，则剩余元素会被默认初始化。
- 如果初始化列表的元素个数大于数组的大小，则会产生编译错误。

```
int *p = new int[10]{0,1,2,3,4,5,6,7,8,9,10}; // 错误，初始化列表的元素个数大于数组的大小
```

- 如果new分配一个大小为0的数组，会返回一个空指针。

```
int *p = new int[0]; // 返回一个空指针
```

### **动态数组与智能指针**
- 标准库提供了一个可以管理new分配的数组的unique_ptr版本。

```
unique_ptr<int[]> up(new int[10]); // 分配一个包含10个int的数组
// 使用下标运算符访问数组元素
for (int i = 0; i < 10; i++) {
    up[i] = i;
}
```

- 也可以使用shared_ptr来管理动态数组。
  - 但是shared_ptr默认使用delete销毁对象，因此需要使用**自定义的删除器**来管理动态数组。
  - 并且shared_ptr未定义下标运算符，因此需要使用智能指针的**成员函数get()**来访问数组元素。

```
shared_ptr<int> sp(new int[10], [](int *p) { delete[] p; });
// 使用get()访问数组元素
for (int i = 0; i < 10; i++) {
    *(sp.get() + i) = i;
}
```

## allocator类

当分配一大块内存时，我们通常希望按需构造对象。同时我们希望将**内存分配**和**对象构造**分离，这样我们可以在需要的时候再构造对象。分离内存分配和对象构造可以让我们更灵活地管理内存，避免资源浪费。

### **allocator类**
- 定义在头文件<memory>中
- 能够将内存分配和对象构造分离

```
allocator<T> alloc; // 定义一个allocator对象alloc
T *p = alloc.allocate(n); // 为n个T类型的对象分配原始的未构造的内存,返回一个指向首元素的指针
alloc.construct(p, args); // 在p指向的内存中构造一个T类型的对象，使用args初始化
alloc.destroy(p); // 销毁p指向的T类型的对象
alloc.deallocate(p); // 释放p指向的内存
```

### **使用allocator类时的注意点**
- 使用allocate返回的指针未构造，不能直接使用。
- 使用construct构造对象时，需要传递对象的构造参数。
- 使用destroy销毁对象时，对象需要有析构函数。
- 使用deallocate释放内存时，需要传递的指针是allocate返回的指针。

### **allocator的两个伴随算法**

```
allocator<string> alloc;
vector<int> v(10) = {0,1,2,3,4,5,6,7,8,9};
auto p = alloc.allocate(v.size() * 2);

uninitialized_copy(v.begin(), v.end(), p);  //将v中的元素拷贝到p中,p指向的内存需要足够大,能够容纳v中的元素。多余的内存会被默认初始化
uninitialized_copy_n(v.begin(), 10, p);  //将v中的前10个元素拷贝到p中,p指向的内存需要足够大,能够容纳10个元素
uninitialized_fill(p, p + v.size(), "hello");  //将p指向的内存填充为"hello"
uninitialized_fill_n(p, 10, "world");  //将p指向的内存的前10个元素填充为"world"
```

# 练习题参考
[[notes/第二部分-标准库总结：文本查询程序]]
