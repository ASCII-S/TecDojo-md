[C++primer](c++primer.md)
---
# 拷贝控制

本章会学习类如何控制该类型对象拷贝、赋值、移动或销毁时做什么。类通过一些特殊的成员函数控制这些操作，包括：拷贝构造函数、移动构造函数、拷贝赋值运算符、移动赋值运算符以及析构函数。

**类的五种特殊成员函数:拷贝控制操作(copy control operations)**
- 拷贝构造函数(copy constructor)
- 移动构造函数(move constructor)
- 拷贝赋值运算符(copy assignment operator)
- 移动赋值运算符(move assignment operator)
- 析构函数(destructor)

**拷贝控制操作的时机**
- 拷贝构造函数：当用一个对象初始化另一个对象时
- 移动构造函数：当用一个右值对象初始化另一个对象时
- 拷贝赋值运算符：当用一个对象赋值给另一个对象时
- 移动赋值运算符：当用一个右值对象赋值给另一个对象时
- 析构函数：当对象离开作用域时

# 拷贝、赋值与销毁

## 拷贝构造函数

### **拷贝构造函数**

如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。





```c++

#include <iostream>
class Sales_data {
public:
    Sales_data(std::string s, unsigned cnt, double price) 
        : bookNo(s), units_sold(cnt), revenue(cnt * price) {}
    Sales_data(const Sales_data& other) = default;
        // 常用const,因为拷贝构造函数不改变被拷贝对象
        // 拷贝构造函数的参数必须是引用类型,否则会无限递归
            //如果参数不是引用，传递对象时会触发拷贝构造
            //拷贝构造又需要拷贝参数，形成无限循环
        // 拷贝构造函数通常不应该是explicit的，因为拷贝初始化在以下情况下隐式转换
            // 1. 用一个对象初始化另一个对象
            // 2. 将对象作为实参传递给一个非引用类型的形参
            // 3. 从一个返回类型为非引用类型的函数返回一个对象
            // 4. 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
    
    // 打印类
    void print() {
        std::cout << "bookNo: " << bookNo << std::endl;
        std::cout << "units_sold: " << units_sold << std::endl;
        std::cout << "revenue: " << revenue << std::endl;
    }
private:
    std::string bookNo;
    int units_sold = 0;
    double revenue = 0.0;
};

```

```cpp

// 展示拷贝构造函数
Sales_data a("123", 10, 10.0);
Sales_data b(a);
std::cout << "a:" << std::endl;
a.print();
std::cout << "b:" << std::endl;
b.print();

```



### **合成拷贝构造函数**

如果一个类没有定义拷贝构造函数，编译器会自动生成一个。这个合成的拷贝构造函数的行为与类中数据成员的类型有关。
- 对类类型的成员，会使用其拷贝构造函数来拷贝
- 对内置类型或复合类型成员，会逐成员变量进行拷贝



### **拷贝初始化**



拷贝初始化(copy initialization)：使用拷贝构造函数初始化一个对象。

- 拷贝初始化与直接初始化
  - 直接初始化时,编译器使用普通的函数匹配来选择与实参最匹配的构造函数
  - 拷贝初始化时,编译器将右侧运算对象拷贝到正在创建的对象中,如果需要的话还要进行类型转换
    

```C

#include <iostream>
using namespace std;
string s1("hello"); //直接初始化,用()
string s2(s1); //直接初始化
string s3 = s1; //拷贝初始化,用=定义变量时
string s4 = "hello"; //拷贝初始化
string s5 = string(10, 'c'); //拷贝初始化

```



- 拷贝初始化在以下情况发生
  - 用=定义变量时
  - 将对象作为实参传递给非引用类型的形参时
  - 从一个返回类型为非引用类型的函数返回一个对象时
  - 用花括号列表初始化一个数组中的元素或一个聚合类中的成员时



### **拷贝初始化的限制**
- 当构造函数被声明为explicit时，不能用于隐式类型转换
- 拷贝初始化会涉及隐式转换，因此受到explicit构造函数的限制
- 直接初始化可以显式调用explicit构造函数





```c++

vector<int> v1(10);  // 正确：直接调用explicit构造函数，函数原型为vector<int>(int)
vector<int> v2 = 10; // 错误：不能隐式转换，
void f(vector<int>); // f的参数进行拷贝初始化
f(10);               // 错误：需要隐式转换将int转换成vector<int>
f(vector<int>(10));  // 正确：显式构造临时对象

```



### **拷贝省略(copy elision)**

在某些情况下，编译器会自动省略拷贝/移动操作，这种行为称为拷贝省略。



- 返回值优化(RVO,Return Value Optimization)
  - 没有RVO时：
    - 在createString函数内部，先构造一个临时的std::string("Hello")对象。
    - 返回时，用拷贝构造函数把这个临时对象拷贝到外部变量s。
    - 销毁临时对象。
  - 有RVO时：
    - 编译器会直接在s的内存空间上构造"Hello"，省略了临时对象的创建和拷贝，效率更高。
    

```C

    std::string createString() {
        return std::string("Hello");  // 可能直接在调用处构造，不调用拷贝/移动
    }

    std::string s = createString();  // 直接构造s，跳过临时对象的创建和拷贝
    std::cout << s << std::endl;

```

- 命名返回值优化(NRVO,Named Return Value Optimization)
    - 这里的函数采用了值返回，而不是引用或指针。因此不会未定义
    - 命名返回值优化（Named Return Value Optimization, NRVO） 是 C++ 编译器的一种优化技术。它的作用是：当你在函数里定义了一个“有名字的局部变量”，并且把它作为返回值返回时，编译器可以直接在调用者的内存空间上构造这个变量，从而避免一次拷贝或移动操作。

```C

    std::string createString() {
        std::string result("Hello");  // 命名的局部变量
        return result;               // 可能直接在调用处构造
    }

    std::string s = createString();  // 直接构造s，跳过拷贝
    std::cout << s << std::endl;

```


- 临时对象优化(Temporary Object Optimization)
    - 临时对象优化其实是RVO的一个特例，指的是在表达式中直接生成目标对象，避免创建多余的临时变量。
    - 没有优化时：
      - 先创建一个临时的std::string("Hello")对象。
      - 用拷贝构造函数把临时对象拷贝到s。
      - 销毁临时对象。
    - 有优化时：
      - 编译器会直接在s的内存空间上构造"Hello"，根本不会创建临时对象。

```C

    std::string s = std::string("Hello");  // 可能直接构造s，不创建临时对象    

```


    
## 拷贝赋值运算符

与拷贝构造函数的区别：
- 拷贝构造函数用于==创建新对象==时，用一个已存在的对象初始化新对象
- 拷贝赋值运算符用于==已存在对象==，把一个对象的内容赋值给另一个已经存在的对象

### **重载运算符**

- 本质：重载运算符本质上是特殊命名的函数
- 命名规则：operator关键字后接运算符符号（如operator=）
- 特性：
  - 有返回类型和参数列表
  - 某些运算符（包括赋值运算符）必须定义为成员函数

### **赋值运算符的定义**





```c++

class Foo {
public:
    // 赋值运算符
    Foo& operator=(const Foo& rhs){
        // 赋值操作
        return *this;
    }; 
};


```

```cpp

Foo a, b, c;
a = b;  // 等价于 a.operator=(b);

```



- 成员函数：左侧运算对象绑定到隐式this参数
- 参数：右侧运算对象作为显式参数传递
- 返回类型：
  - 通常返回左侧运算对象的引用（Foo&）以实现链式赋值
    

```C

    a = b = c;  // 等价于 a.operator=(b.operator=(c));    

```

  - 与内置类型赋值操作保持一致
  - 标准库容器要求元素类型的赋值运算符返回左侧运算对象的引用
- 注意:
  - 赋值运算符必须能够正确处理自赋值情况    

```C

    Foo& Foo::operator=(const Foo& rhs) {
        if (this != &rhs) {  // 自赋值检查
            // 赋值操作
        }
        return *this;
    }

```


  - 合成赋值运算符（编译器自动生成的）会执行成员逐个赋值

### **合成拷贝赋值运算符**





```c++

// 编译器生成的合成拷贝赋值运算符示例
Sales_data& Sales_data::operator=(const Sales_data &rhs)
{
    bookNo = rhs.bookNo;      // 调用string的赋值运算符
    units_sold = rhs.units_sold; // 内置int类型的赋值
    revenue = rhs.revenue;    // 内置double类型的赋值
    return *this;            // 返回左侧对象的引用
}

```



- 成员赋值顺序：按照成员**声明顺序**依次赋值
- 赋值方式：
  - 类类型成员：调用该类型的拷贝赋值运算符
  - 内置类型成员：直接赋值
  - 数组成员：逐个元素赋值
- 返回值：总是返回左侧运算对象的引用（*this）
- 何时需要自定义拷贝赋值运算符：
  - 类中包含动态内存管理（如指针或智能指针）
  - 类中包含需要深拷贝的成员

## 析构函数
析构函数负责在对象生命周期结束时执行清理工作，主要包括：
- 释放资源：如动态内存、文件句柄、网络连接等
- 执行收尾操作：如保存状态、日志记录等
- 成员销毁：按逆序自动销毁类成员

### **析构函数完成什么工作**

- 执行顺序
    

```C

    ~ClassName() {
        // 析构函数体（自定义清理逻辑）
        // ...
    } // 隐式析构部分（成员自动销毁）

```


  - ​首先执行函数体内的自定义清理代码
  - ​然后自动执行隐式析构部分（成员销毁）

- 成员销毁规则
    |  成员类型  |                                销毁行为                                |
    | :--------: | :--------------------------------------------------------------------: |
    | 类类型成员 |                        自动调用该成员的析构函数                        |
    |  内置类型  |                        无操作（如int、float等）                        |
    |  普通指针  |          仅销毁指针本身，不释放指向的内存（容易导致内存泄漏）          |
    |  智能指针  | 自动调用其析构函数释放管理的内存（如std::shared_ptr、std::unique_ptr） |



### **析构函数何时被调用**

- 变量离开其作用域
- 对象成员被销毁
- 容器销毁时其元素被销毁
- 动态分配对象被delete
- 临时对象的完整表达式结束
  

```C

    Sales_data getTemp();  // 返回临时对象的函数

    void useTemp() {
        getTemp();  // 临时对象在完整表达式结束后析构
        Sales_data&& r = getTemp();  // 延长临时对象生命周期
    } // r离开作用域时析构
    

```


  - 完整表达式
    - 完整表达式是指不是其他表达式子部分的表达式，它是C++中最大的独立计算单元。当完整表达式执行完毕后，它所创建的临时对象就会被销毁。
    

```C


    // 示例1：简单完整表达式
    std::string("temp"); // 创建临时string对象
    // 分号结束，临时对象立即销毁

    // 示例2：函数参数中的临时对象
    void process(const std::string& s);
    process(std::string("temp")); 
    // 临时对象生命周期延长到函数调用结束

    // 示例3：绑定到引用延长生命周期
    {
        std::string a = std::string("hello") + std::string(" world");
    // 两个临时string对象在各自完整表达式结束后销毁
    }
    

```


### **合成析构函数**

- 如果一个类没有定义析构函数，编译器会自动生成一个。这个合成的析构函数的行为与类中数据成员的类型有关。
- 多数情况下，合成析构函数体为空。
- 对某些类，合成析构函数会阻止销毁操作。
  - 类有不可销毁的成员
  - 类继承自一个不可销毁的基类


---
## 三/五法则

### **三/五法则(Rule of Three/Five)**
  - 三法则（C++98/03）：
    - 如果一个类需要自定义以下任何一个，那么它通常需要自定义全部三个：
      - 拷贝构造函数
      - 拷贝赋值运算符
      - 析构函数
  - 五法则（C++11）：
    - 如果一个类需要自定义以下任何一个，那么它通常需要自定义全部五个：
      - 拷贝构造函数
      - 拷贝赋值运算符
      - 析构函数
      - 移动构造函数
      - 移动赋值运算符

### **析构函数依赖拷贝与赋值操作**
如果一个类需要自定义析构函数，那么它几乎肯定也需要自定义拷贝构造函数和拷贝赋值运算符。这是因为：

- 需要析构函数通常意味着类管理着某种资源（如动态内存）
- 合成拷贝操作只是简单拷贝成员，会导致多个对象共享同一资源
- 当这些对象被销毁时，同一资源会被多次释放，导致未定义行为

### **拷贝与赋值操作的相互依赖**
如果一个类需要自定义拷贝构造函数，那么它几乎肯定也需要自定义拷贝赋值运算符，反之亦然。这是因为：

- 需要自定义拷贝操作通常意味着类有特殊的拷贝语义
- 拷贝构造函数和拷贝赋值运算符通常需要保持一致的行为
- 但这类类不一定需要自定义析构函数



---
## 使用=default
通过在函数声明后使用=default来显式要求编译器生成合成的版本。

```c++


class Sales_data {
public:
    Sales_data() = default;
    Sales_data(const Sales_data&) = default;
    Sales_data& operator=(const Sales_data&) = default;
    ~Sales_data() = default;
private:
    std::string bookNo;
    int units_sold = 0;
    double revenue = 0.0;
};


```


---
## 阻止拷贝

### **删除函数**
删除函数是C++11引入的特性，允许我们明确禁止某些函数的调用：





```c++


struct NoCopy {
    NoCopy() = default;  // 使用合成的默认构造函数
    
    // 阻止拷贝
    NoCopy(const NoCopy&) = delete;
    NoCopy& operator=(const NoCopy&) = delete;
    
    ~NoCopy() = default;  // 使用合成的析构函数
};


```



- 语法要求
  - 必须在函数第一次声明时使用=delete
  - 适用于任何函数，不仅仅是特殊成员函数
- 与=default的区别
    |   特性   |          =default          |       =delete        |
    | :------: | :------------------------: | :------------------: |
    | 使用时机 |     可在类外定义时使用     | 必须在首次声明时使用 |
    | 适用范围 |      仅限特殊成员函数      |       任何函数       |
    |   目的   | 显式请求编译器生成默认实现 |  完全禁止函数的使用  |



### **析构函数不能被删除**
在C++中，析构函数不能被删除（=delete）是因为这会破坏语言的对象生命周期管理机制。每个对象在生命周期结束时都需要被正确销毁，删除析构函数会使这一基本保证失效。



### **合成的拷贝控制成员可能是删除的**
当类满足某些特定条件时，编译器会将==合成的拷贝控制成员==定义为删除的函数（deleted functions）。

以下是各种情况的详细说明：

- 合成析构函数被删除
  - ​条件​：类的某个成员的析构函数是删除的或不可访问的（如private且类外不可访问）

    

```C


    class NoDtorMember {
        NoDtor m;  // 假设NoDtor的析构函数是=delete或private
    };
    // 编译器将为NoDtorMember生成~NoDtorMember() = delete
    

```


- 合成拷贝构造函数被删除
  - 条件1：类的某个成员的拷贝构造函数是删除的或不可访问的
  - 条件2：类的某个成员的析构函数是删除的或不可访问的
    

```C


    class NoCopyMember {
        NoCopy m;  // 假设NoCopy的拷贝构造函数或析构函数是=delete
    };
    // NoCopyMember的合成拷贝构造函数被删除
    

```


- 合成拷贝赋值运算符被删除
  - 条件1：类的某个成员的拷贝赋值运算符是删除的或不可访问的
  - 条件2：类有const成员
  - 条件3：类有引用成员
    

```C

++
    class ConstMember {
        const int x;
    };
    // ConstMember的合成拷贝赋值运算符被删除
    

```


- 合成默认构造函数被删除
  - 条件1：类的某个成员的析构函数是删除的或不可访问的
  - 条件2：类有引用成员且无类内初始化器
  - 条件3：类有const成员且无类内初始化器，且其类型未显式定义默认构造函数
    

```C


    class RefMember {
        int& ref;  // 无类内初始化器
    };
    // RefMember的合成默认构造函数被删除
    

```



### **private拷贝控制**

在C++11标准之前，通过将拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝。由于只声明不定义，编译器会报错,以此达到阻止拷贝的目的。





```c++


class PrivateCopy {
private:
    // 拷贝控制成员声明为private且不实现
    PrivateCopy(const PrivateCopy&);  // 只声明不定义,当试图拷贝时,编译器会报错
    PrivateCopy& operator=(const PrivateCopy&);  // 只声明不定义,当试图拷贝时,编译器会报错
};


```



- **与现代方法(=delete)的比较:**
    |      特性      |   private未实现方法    |         =delete方法          |
    | :------------: | :--------------------: | :--------------------------: |
    |  错误发现时机  |    用户代码：编译时    |          全部编译时          |
    |   代码清晰度   |      意图不够明确      |       明确表达设计意图       |
    |    适用范围    |   仅限于拷贝控制成员   |        可用于任何函数        |
    |  C++标准支持   |        C++98/03        |         C++11及以上          |
    | 错误信息友好度 | 较差（特别是链接错误） | 更好（直接指出被删除的函数） |



---
# 拷贝控制和资源管理

- 管理类外资源的类必须定义拷贝控制成员（拷贝构造函数、拷贝赋值运算符、析构函数）
- 需要析构函数的类通常也需要拷贝构造函数和拷贝赋值运算符

- 两种拷贝语义：
  - 1. 类值行为 (Value-like)
    - 特点：
      - 对象拥有自己的独立状态
      - 拷贝操作创建完全独立的副本
      - 修改副本不影响原对象，反之亦然
    - 示例：
      - 标准库容器
      - std::string类
  - 2. 类指针行为 (Pointer-like)
    - 特点：
      - 对象共享底层状态
      - 拷贝操作创建共享相同底层数据的副本
      - 修改副本会影响原对象，反之亦然
    - 示例：
      - std::shared_ptr
      - StrBlob类

## 行为像值的类

- 标准库容器和std::string类都表现出值行为
- 值行为的特点：
  - 独立对象状态：每个对象管理自己的资源副本
  - 深拷贝语义：拷贝操作复制资源内容而非指针
  - 完整拷贝控制：必须定义拷贝构造、拷贝赋值和析构函数
  - 自给自足：对象生命周期内不依赖其他对象的状态

### **类值拷贝赋值运算符**

赋值运算符需要结合析构函数和拷贝构造函数的功能：
- 析构：释放左侧对象的现有资源
- 构造：从右侧对象拷贝新资源
- 赋值：更新数据成员



```cpp


HasPtr& HasPtr::operator=(const HasPtr &rhs) {
    auto newp = new string(*rhs.ps);  // 1. 先拷贝右侧对象,保证了自赋值安全
    delete ps;                        // 2. 再释放左侧资源
    ps = newp;                        // 3. 更新指针
    i = rhs.i;                        // 4. 拷贝内置类型
    return *this;                     // 5. 返回引用
}


```



## 行为像指针的类

- 标准库容器和std::shared_ptr类表现出指针行为
- 指针行为的特点：
  - 共享状态：多个对象共享相同的底层数据
  - 浅拷贝语义：拷贝操作只复制指针，不复制指向的内容
  - 引用计数：跟踪有多少对象共享同一资源
  - 自动释放：当最后一个使用资源的对象被销毁时才释放资源

### **使用引用计数管理资源**

- **核心工作流程**
  - 初始化：创建对象时设置引用计数为1
  - 拷贝构造：共享资源并递增引用计数
  - 析构：递减引用计数，归零时释放资源
  - 赋值：先递增右侧计数，再递减左侧计数

- **计数器存储位置**
  - 不能作为普通成员变量：因为需要被所有共享对象共同访问
  - 动态内存分配：使用指针指向堆上的计数器
  - 共享访问：所有共享对象通过指针访问同一计数器

- **采用计数器的类示例**
  

```cpp


  class HasPtr {
  public:
      // 构造函数
      HasPtr(const std::string &s = std::string())
          : ps(new std::string(s)), i(0), use(new std::size_t(1)) {}
      
      // 拷贝构造函数
      HasPtr(const HasPtr &p) : ps(p.ps), i(p.i), use(p.use) { ++*use; }
      
      // 拷贝赋值运算符
      HasPtr& operator=(const HasPtr&);
      
      // 析构函数
      ~HasPtr();
      
  private:
      std::string *ps;    // 指向共享的字符串
      int i;              // 普通成员
      std::size_t *use;   // 指向引用计数器
  };
  

```


  - 析构函数实现
    

```cpp


    HasPtr::~HasPtr() {
      if (--*use == 0) {  // 原子操作递减计数
          delete ps;      // 释放共享字符串
          delete use;     // 释放计数器
      }
    }
    

```


  - 拷贝赋值运算符实现
    

```cpp


    HasPtr& HasPtr::operator=(const HasPtr &rhs) {
      ++*rhs.use;         // 先递增右侧计数（处理自赋值）
      
      if (--*use == 0) {  // 再递减左侧计数
          delete ps;
          delete use;
      }
      
      // 拷贝数据成员
      ps = rhs.ps;
      i = rhs.i;
      use = rhs.use;
      
      return *this;
      }
      

```



---
# 交换操作

## 为什么需要自定义 swap
对自定义类来说，标准库的 swap 函数会进行三次拷贝，而自定义的 swap 函数只需要交换指针，不需要进行拷贝。

### **标准 swap 的问题**
- 性能低下：默认 swap 需要 1 次拷贝构造 + 2 次赋值操作
  - 具体为：
    - 1 次拷贝构造：用于创建临时对象
    - 2 次赋值操作：用于将临时对象赋值给左侧对象和右侧对象
- 不必要的资源分配：对于管理资源的类会导致多次资源拷贝

### **自定义 swap 的优势**
- 性能大幅提升：仅需交换指针，无资源分配/释放
- 异常安全：仅涉及指针操作，不会抛出异常

## **自定义 swap 示例**

**类内声明友元函数**


```cpp


class HasPtr {
    friend void swap(HasPtr&, HasPtr&); // 声明为友元以访问私有成员
    // ... 其他成员定义 ...
};


```



**类外定义swap函数**


```cpp


inline void swap(HasPtr &lhs, HasPtr &rhs) {
    using std::swap;            // 引入标准库swap
    swap(lhs.ps, rhs.ps);       // 交换指针成员
    swap(lhs.i, rhs.i);         // 交换内置类型成员
}


```



## swap 函数的最佳实践

### 关键概念

1. **优先使用类型特定的 swap 版本**：当为自定义类型实现 swap 时，应该优先调用该类型自己的 swap 实现，而不是直接调用 `std::swap`

2. **未限定调用 swap**：在自定义 swap 函数中，应该使用未限定的 `swap` 调用（不带命名空间前缀），而不是 `std::swap`

### swap实践对比？

#### 正确方式


```cpp


void swap(Foo &lhs, Foo &rhs) {
    using std::swap;  // 将 std::swap 引入当前作用域
    swap(lhs.h, rhs.h);  // 未限定调用，优先使用 HasPtr 版本的 swap
    // 交换其他成员...
}


```



#### 错误方式


```cpp


void swap(Foo &lhs, Foo &rhs) {
    std::swap(lhs.h, rhs.h);  // 强制使用 std::swap，忽略可能存在的更好实现
    // 交换其他成员...
}


```



### 未限定调用swap的工作原理

1. **查找顺序**：
   - 首先查找参数类型所在命名空间的 swap（ADL，参数依赖查找）
   - 然后查找当前作用域中的 swap（通过 using 声明引入的 std::swap）
   - 最后查找 std 命名空间的 swap

2. **性能优势**：
   - 类型特定的 swap 通常针对该类型优化（如避免不必要的拷贝）
   - 内置类型会回退到 std::swap

### 注意事项

- 即使使用了 `using std::swap`，类型特定的 swap 声明也不会被隐藏
- 这种设计遵循 C++ 的名称查找规则，确保总是调用最合适的 swap 实现

## 拷贝并交换（Copy and Swap）技术详解

拷贝并交换技术，通过编译器自动创建拷贝，再由交换操作实现快速转移资源。

### 基本实现模式



```cpp


ClassName& ClassName::operator=(ClassName rhs) { // 注意：按值传递
    swap(*this, rhs);  // 交换当前对象与副本的内容
    return *this;      // 副本rhs被销毁，自动清理旧资源
}


```



### 关键特性分析

#### 参数传递方式
- **按值传递**：创建右侧运算对象的完整副本
- 隐含调用了拷贝构造函数，完成**深拷贝**

#### 自动资源管理
- 交换后，`rhs`持有原对象的资源
- 函数返回时`rhs`自动析构，释放旧资源

#### 优势总结表

| 特性         | 传统实现     | 拷贝并交换 |
| ------------ | ------------ | ---------- |
| 自赋值安全   | 需要显式检查 | 自动处理   |
| 异常安全     | 需要精心设计 | 自动保证   |
| 代码复杂度   | 较高         | 极简       |
| 资源泄漏风险 | 存在         | 无         |

### 技术优势详解

#### 自赋值安全
   - 创建副本的操作隔离了左右操作数
   - 即使`*this`和`rhs`是同一对象，副本机制保证了正确性

#### 异常安全
   - 所有可能抛出异常的操作(如拷贝构造)在交换前完成
   - 要么完全成功，要么完全不修改原对象

#### 资源管理
   - 利用RAII原则，通过局部对象析构自动释放资源
   - 避免了手动资源管理的复杂性

### 实现注意事项

1. 必须正确定义拷贝构造函数和swap函数
2. swap函数应该实现为不抛出异常的操作
3. 适用于管理资源的类，特别是需要深拷贝的类



---
# 拷贝控制示例

这个设计要解决的是消息与目录的多对多关系管理问题，类似于电子邮件系统中：

- 一条消息可以属于多个文件夹（如"工作"+"重要"）
- 每个文件夹包含多条消息
- 消息内容只有一份副本（修改后所有文件夹中的显示同步更新）

[13-拷贝控制示例: Message 和 Folder 类的拷贝控制设计](./notes/13-拷贝控制示例.md)


---
# 动态内存管理类

- 某些类需要在运行时分配可变大小的内存空间。
  - 这种类通常可以 (并且如果它们确实可以的话，一般应该) 使用标准库容器（如vector）来保存它们的数据。
  - 某些类需要自己进行内存分配。这些类一般来说必须定义自己的拷贝控制成员来管理所分配的内存。


本节会设计一个vector类的简化版本-StrVec，并实现其拷贝控制成员函数。
[设计一个vector类的简化版本-StrVec](./notes/13-设计一个vector类的简化版本-StrVec.md)

---
# 对象移动

## 右值引用

### 右值引用（rvalue reference）的定义与引入目的

* 用法：`T&&`
* 引用**右值**，即**将要销毁的临时对象**。
* 设计目的：**接管资源所有权**，支持**移动语义**，提升性能。

### 右值引用的绑定规则

```cpp
int i = 42;
int &r = i;              // ✅ 左值引用绑定左值
int &&rr1 = i;           // ❌ 错误：右值引用不能绑定左值
int &r2 = i * 42;        // ❌ 错误：左值引用不能绑定右值
const int &r3 = i * 42;  // ✅ const 左值引用可以绑定右值
int &&rr2 = i * 42;      // ✅ 右值引用绑定右值
```

* **变量名是左值**，即使它是 `T&&` 类型：

  ```cpp
  int &&rr = 42;        // rr 是右值引用类型，但表达式 rr 是左值
  int &&rr2 = rr;       // ❌ 错误，rr 是左值，不能绑定右值引用
  ```


### 为什么右值引用可以“移动”资源

* 因为右值引用 **唯一绑定即将销毁的对象**：

  * 该对象**没有其他用户**；
  * 我们可以**安全地窃取其状态**（如指针、缓冲区）；
* 用于移动构造函数、移动赋值函数等场景。


### 左值 vs 右值

| 表达式类型         | 描述                         |
| ------------------ | ---------------------------- |
| **左值（lvalue）** | 有名字、可寻址、生命周期持久 |
| **右值（rvalue）** | 临时值，无名字，将被销毁     |


### std::move 函数

**作用：**

* 将**左值显式转换为右值引用**，从而启用移动操作。

**示例：**

```cpp
std::string s = "hello";
std::string t = std::move(s);  // 移动构造，t 接管 s 的资源
```

* 此后 `s` 进入“移后状态”：

  * 是有效对象，可析构；
  * 但内容不可用，不应再访问。


**重要警告 ⚠️**

```cpp
std::string s = "abc";
std::string t = std::move(s); // t 拿走了 s 的资源
std::cout << s;               // ⚠️ 未定义行为，不应再访问 s
```

**正确的用法：**

* `std::move()` 后，只可：

  * 对对象重新赋值；
  * 或让其析构；
  * 不再读取其值！


**命名使用注意**

* `std::move` **不能使用 `using std::move;`**，应始终写为 `std::move`；
* 避免与其他 `move` 命名冲突（详细原因见 C++ 标准第 18.2.3 节）。


## 移动构造和移动赋值运算符-移动操作

### 对类引入移动操作

#### 移动操作的目的

* 当我们自定义的类（如 `StrVec`）**管理资源（如动态分配的内存）** 时，拷贝操作通常较为昂贵；
* **移动操作**允许我们 **“窃取”资源所有权**，避免不必要的分配与拷贝；
* 为此，需要显式定义：

  * **移动构造函数**
  * **移动赋值运算符**


#### 移动构造函数定义

```cpp
StrVec::StrVec(StrVec &&s) noexcept
  : elements(s.elements), first_free(s.first_free), cap(s.cap) {
    s.elements = s.first_free = s.cap = nullptr;
}
```

**说明：**

* **参数类型**：右值引用 `StrVec &&s`，表示可以“窃取” `s` 的资源；
* **初始化列表**：直接接管 `s` 的指针资源（不再重新分配内存）；
* **重要步骤**：将 `s` 的指针成员都置空，确保其析构不会释放刚刚转移的资源；
* **`noexcept`**：表示此函数**不抛出异常**，有助于标准库优化容器行为（如移动而非拷贝）。

**为何必须置空移后对象？**

```cpp
s.elements = s.first_free = s.cap = nullptr;
```

* **原因：出于对==该类的析构函数的设计==考虑**

  * `StrVec::~StrVec()` 会调用 `free()` → `deallocate(elements, ...)`；
  * 如果不置空，移后对象析构时会**重复释放已被接管的内存** → **未定义行为或崩溃**；
  * 置空后，`free()` 会检查 `elements == nullptr`，避免释放。



### 移动构造函数中的noexcept

#### 移动操作在功能上通常不抛出异常

* 移动构造/赋值通常只“窃取”资源，不涉及资源分配，因此一般不会抛出异常。
* 但从语言机制上说，移动操作是**允许抛出异常**的。

#### 标准库的容器如何处理移动操作的异常

* 例如 `vector` 要求：若 `push_back` 抛出异常，`vector` 自身状态不能改变。
* 为实现该保障，`vector` 在重新分配内存时会优先选择**不会抛出异常**的移动操作；否则，它会使用拷贝操作以确保异常发生时旧数据不变。

#### 避免移动操作的异常：使用 `noexcept` 关键字

* 标准库无法自动判断某个移动构造是否抛出异常。
* 若未使用 `noexcept`，容器默认认为移动可能抛异常，从而**退回使用拷贝构造**，导致性能下降。

**`noexcept` 的声明位置与用法**

* 需要在类声明和函数定义中都加上 `noexcept`：

  ```cpp
  class StrVec {
  public:
      StrVec(StrVec&&) noexcept;  // 声明
  };

  StrVec::StrVec(StrVec &&s) noexcept : /*成员初始化*/ {
      // 构造函数体
  }
  ```

### 移动赋值运算符

#### 功能

* 移动赋值运算符的职责：

  * 释放当前对象的已有资源；
  * 从右侧右值对象接管资源；
  * 将右侧对象置于“可析构状态”（即置空指针）；
  * 返回当前对象的引用。

#### 示例代码结构

```cpp
StrVec &StrVec::operator=(StrVec &&rhs) noexcept {
    if (this != &rhs) {
        free();                    // 释放已有资源
        elements = rhs.elements;   // 接管 rhs 的资源
        first_free = rhs.first_free;
        cap = rhs.cap;
        rhs.elements = rhs.first_free = rhs.cap = nullptr; // 置空 rhs
    }
    return *this; // 返回自身引用
}
```

#### 安全性关键点

* 在释放资源前确保不是自赋值；
* 始终在接管资源后将源对象置空；
* 返回引用以支持链式赋值。

### 移后源对象必须可析构

#### 可析构的必要性

* 移动操作不会销毁源对象；
* 源对象在移动后仍需进入一个**可以安全析构**的状态；
* > StrVec 中通过将指针成员设为 `nullptr` 实现了这一点。

#### 对象“有效性”的含义

* 移后源对象必须处于“有效”状态，即：

  * 可以安全销毁；
  * 可以安全赋值；
  * 不依赖当前值即可安全使用。
* “有效”不意味着值有意义，**仅表示可以继续操作而不会导致程序错误**。

#### 移后对象的使用限制

* 标准库中的移动对象（如 `string`, `vector`）保证可以调用 `empty()`、`size()`；
* 但不保证内容为“空”或具有特定状态；
* **用户代码不能依赖于移后对象的值**。

#### 实践要求

* 自定义类型的移动操作应确保：

  * **析构安全**：成员指针设为 `nullptr`；
  * **状态合法**：对象可以赋值、析构，不会触发未定义行为；
  * **值不可依赖**：不对剩余成员状态做任何假设或使用。

### 合成的移动操作

#### 合成条件与限制

* 编译器合成移动构造函数和移动赋值运算符的前提条件：

  * 所有**非 static 成员**都必须支持移动构造和移动赋值；

    * 内置类型：始终可移动；
    * 类类型：其本身必须支持移动操作。
  * 类**没有**用户自定义的：

    * 拷贝构造函数；
    * 拷贝赋值运算符；
    * 析构函数。

* 若不满足上述条件：

  * 编译器**不会合成**移动操作；
  * 如果显式 `= default` 且编译器不能为某个成员合成移动操作，该移动操作会被**定义为删除的函数**。

#### 何时定义合成删除的移动操作

* 以下情况会导致移动操作被定义为**删除的函数**：

  * 没定义：成员类类型有用户定义的拷贝构造函数但**无移动构造函数**；
  * 定义没：成员类型的移动操作是**删除的或不可访问的**；
  * 类含有 `const` 成员或引用成员（移动赋值运算符不能重新赋值这些成员）；
  * 类的析构函数是删除的或不可访问的。

**示例：成员不支持移动**

```cpp
struct Y {
    Y(const Y&); // 用户定义了拷贝构造
    // 没有定义移动构造
};

struct hasY {
    hasY() = default;
    hasY(hasY&&) = default; // ❌ 移动构造函数是删除的
    Y mem;
};
```

* `hasY` 显式要求生成移动构造，但由于 `Y` 不可移动，该构造函数被删除；
* 若未声明 `hasY(hasY&&) = default`，则不会合成移动构造，编译器使用拷贝替代（若存在）。

**移动操作导致合成删除的拷贝操作**

* 如果类**定义了移动构造函数/赋值运算符**，而没有定义对应的拷贝构造函数/赋值运算符：

  * 编译器会将拷贝构造/赋值运算符**定义为删除的函数**；
  * 开发者**必须手动定义拷贝操作**。

## 移动构造和移动赋值运算符-移动与拷贝

### 移动右值，拷贝左值

#### 编译器的函数匹配规则

* 当一个类同时定义了拷贝构造/赋值和移动构造/赋值：

  * **编译器根据实参是左值还是右值来选择最匹配的函数**；
  * 使用标准的**函数重载解析机制**（详见 C++ 函数匹配规则）。

#### 左值与右值的选择行为

| 表达式类型                         | 匹配的函数        |
| ---------------------------------- | ----------------- |
| 左值（如变量）                     | 拷贝构造/赋值函数 |
| 右值（如函数返回值、std::move(x)） | 移动构造/赋值函数 |

**示例代码**

```cpp
StrVec v1, v2;

v1 = v2;           // v2 是左值 → 使用拷贝赋值运算符
v2 = getVec(cin);  // getVec(cin) 是右值 → 使用移动赋值运算符
```

* `v1 = v2;`

  * `v2` 是一个左值；
  * 不能绑定到 `StrVec&&`（右值引用）；
  * 使用 `const StrVec&` 拷贝赋值版本。

* `v2 = getVec(cin);`

  * `getVec(cin)` 是右值；
  * 可以匹配 `StrVec&&` 参数；
  * 拷贝版本需要 const 转换，匹配不如移动版本精确；
  * 因此选用 **移动赋值运算符**。

#### 实用结论

* 若希望使用移动操作，应确保实参是右值。
* 使用 `std::move(obj)` 明确将左值转为右值以启用移动语义。
* 编译器总是偏向匹配更精确的参数类型：右值优先匹配 `T&&` 而非 `const T&`。

### 失败实践：被拷贝的右值

#### 移动构造函数缺失的行为

* 如果类**定义了拷贝构造函数**但**没有定义移动构造函数**：

  * 编译器不会自动合成移动构造函数；
  * 此时，即使传入一个**右值**（如 `std::move(x)`），也只能调用**拷贝构造函数**。

#### 语义层面的解释

* **右值并不总意味着移动**，本质上来说，右值是**即将销毁的对象**；
* **右值只是移动的必要条件，不是充分条件**；
* 如果类没有移动操作，即使提供右值，编译器也会退回使用拷贝操作。

## 移动构造和移动赋值运算符-让拷贝支持移动操作

### 拷贝并交换 赋值运算符与移动操作

#### 移动构造函数与拷贝并交换赋值的配合

```cpp
class HasPtr {
public:
    // 移动构造函数
    HasPtr(HasPtr &&p) noexcept : ps(p.ps), i(p.i) { p.ps = nullptr; }

    // 拷贝并交换赋值运算符，赋值运算符既是移动赋值运算符，也是拷贝赋值运算符
    HasPtr& operator=(HasPtr rhs) {
        swap(*this, rhs);
        return *this;
    }

    // 其他成员同前
};
```

#### 拷贝并交换的优势

* 通过值传递参数 `rhs`：

  * 左值调用时自动走**拷贝构造**；
  * 右值调用时自动走**移动构造**；
* 在函数体中使用 `swap(*this, rhs)`，实现在赋值中：

  * 资源安全释放；
  * 异常安全；
  * 代码简洁且适应性强。

#### 最佳实践

* 使用 **拷贝并交换策略** 实现赋值运算符可以自动兼容拷贝与移动；
* 对于拥有资源的类，建议总是定义五类特殊成员函数


### Message类的移动操作

[对Message类的移动操作实现](./notes/13-拷贝控制示例.md#扩展-移动操作实现)

### 移动迭代器

* **背景问题**
  `StrVec::reallocate` 使用 `for` 循环配合 `construct` 拷贝旧元素。虽然 `uninitialized_copy` 更简洁，但其只执行拷贝，不支持移动。

* **移动迭代器的引入**
  为支持移动，标准库引入了移动迭代器（`move_iterator`）。

  * 它改变解引用行为，将原本返回左值的迭代器转换为返回右值引用。
  * 使用方式：通过 `make_move_iterator(迭代器)` 进行适配。

* **与 uninitialized\_copy 搭配使用**
  移动迭代器可以与 `uninitialized_copy` 组合，实现元素的移动构造：

  ```cpp
  auto last = uninitialized_copy(
      make_move_iterator(begin()),
      make_move_iterator(end()),
      first);
  ```

  * `uninitialized_copy` 调用的是元素的构造函数，使用移动迭代器时将自动使用移动构造函数。

* **注意事项**

  * 并非所有算法都保证能安全地接受移动迭代器。
  * 只有当确信算法不会再访问移动后的元素时，才能使用移动迭代器。
  * 移动后的对象处于不确定状态，应避免再次使用。

* **使用建议**

  * **类内部实现**：推荐使用移动操作来提高性能。
  * **普通用户代码**：避免随意使用 `std::move`，除非明确确认其安全性，否则可能引发难以定位的错误。

## 右值引用和成员函数
