# 数组退化成指针

## 什么是数组退化成指针

在C++中，**数组退化成指针**（Array-to-Pointer Decay）是一个重要的语言特性。当数组作为参数传递给函数时，数组会自动退化（decay）成指向数组首元素的指针。

### 核心概念

- 数组在内存中是连续存储的
- 数组名本身代表数组首元素的地址
- 当数组传递给函数时，传递的不是整个数组，而是指向首元素的指针
- 函数内部无法通过 `sizeof` 获取原始数组的大小

## 代码演示

[数组退化成指针行为](../.CodeReference/array_to_pointer/array_to_pointer.cpp)

## 情景模拟

### 面试官：数组参数有什么等价写法？

**答**：这个很有意思，在C++中这几种写法其实是完全等价的：

```cpp
void func(int arr[]);      // 看起来像数组参数
void func(int arr[10]);    // 指定大小，但实际会被忽略
void func(int* arr);       // 最直接的表示，就是指针
```

编译器会把前面两种都转换成第三种，所以本质上传递的都是指针。

### 面试官：那有办法避免数组退化吗？

**答**：当然有！主要有这几种方法：

```cpp
// 方法1：使用引用 - 保持数组类型
void func(int (&arr)[10]);  // 只能接受大小为10的数组

// 方法2：使用模板引用 - 更灵活
template<typename T, size_t N>
void func(T (&arr)[N]);     // 可以接受任意大小的数组，N会自动推导

// 方法3：传递数组大小 - 传统做法
void func(int* arr, size_t size);  // 手动传递大小信息
```

**推荐使用方法2**，因为它既避免了退化，又保持了类型安全和灵活性。

### 面试官：多维数组传递给函数时会发生什么？

**答**：好的，这是个很有意思的问题。多维数组的退化稍微复杂一点。

让我用代码来解释一下：

```cpp
// 原始多维数组  
char mdarray[2][4] = {"m1", "m2"};  // 字符串字面量，自动添加 '\0'

// 函数声明 - 注意第一维可以省略，但后续维度必须保留
void multi_dim_array(char arr[][4])  // 等价于 void multi_dim_array(char (*arr)[4])
{
    cout << "sizeof(arr): " << sizeof(arr) << endl;             // 输出指针大小
    cout << "strlen(arr[0]): " << strlen(arr[0]) << endl;       // 访问第一行
}
```

**关键点是**：

- **第一维会退化成指针**：`char[2][3]` 变成 `char(*)[3]`
- **后续维度必须保留**：`[3]` 这个信息不能丢，否则编译器不知道如何计算偏移量
- **为什么后续维度不能丢？** 因为编译器需要知道每行有几个元素，才能正确计算 `arr[i]` 的地址

#### 追问：那为什么第一维可以省略，其他维度不行？

**答**：这个问题问得很好！原因是内存布局和地址计算：

```cpp
char mdarray[2][4] = {"m1", "m2"};  // 在内存中是这样排列的：
// 地址:  100  101  102  103  104  105  106  107
// 内容:  'm'  '1' '\0'  (unused) 'm'  '2' '\0'  (unused)
//         ↑                       ↑              
//      arr[0]                  arr[1]         
```

当我们访问 `arr[1]` 时，编译器实际计算的是：

```cpp
arr[1] = arr + 1 * sizeof(char[3]) = arr + 1 * 3 = arr + 3
```

所以编译器**必须知道每行的大小**（即后续维度），才能正确计算偏移量。但第一维的大小对地址计算没影响，所以可以省略。
