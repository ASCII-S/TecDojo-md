# sizeof

## sizeof简介

sizeof是头文件`<cstddef>`中的一个关键字，用于计算对象或类型的大小。

## sizeof计算中的技巧

- 指针的大小是固定的，他是由处理器位数决定的，32位处理器下，指针大小为4字节，64位处理器下，指针大小为8字节。
- 数组作为参数传递给函数时，数组会退化为指针，因此sizeof计算的是指针的大小。
- struct结构体的大小是所有成员变量大小之和，但是要注意内存对齐。
- 类的大小是所有成员变量大小之和，但是要注意内存对齐。
- 字符串的大小是字符串的长度+1，因为字符串末尾有一个空字符`\0`。

## 面试情景模拟

### char类型，char*类型占多少内存？字符串数组呢？

[打印各种基本类型的大小](../.CodeReference/sizeof/sizeof_basic_types.cpp)

### sizeof和strlen有什么区别？

答：功能上来说，sizeof计算的是类型或对象的大小，而strlen计算的是C风格字符串的长度。从实现上来说，sizeof是一个运算符，而strlen是一个函数。

[strlen函数原型详解](../notes/strlen.md)

[sizeof和strlen的区别](../.CodeReference/sizeof/sizeof_strlen.cpp)

### 指针与数组的sizeof区别

[指针与数组的sizeof区别](../.CodeReference/sizeof/sizeof_array_vs_pointer.cpp)

[数组很多情况下会退化为指针](../.CodeReference/array_to_pointer/array_to_pointer.cpp)，在这些情况下sizeof计算的是指针的大小。

### 请你解释一下结构体内存对齐的过程

**背景**
现代计算机中数据以字节（Byte）为单位存储。CPU访问内存是按照字（Word）为单位进行，例如32位cpu一次访问4字节。
**问题**
而结构体成员中，不同类型的成员变量可能占用不同大小的内存空间，例如char，bool只占用一个字节，int占用4个字节。这些成员变量粒度不同，会导致cpu在访问这些成员变量时，需要进行多次访问，从而影响性能。
**解决**
为了避免一个成员变量在内存中存储时，需要跨越多个字节，因此需要将小粒度的成员变量进行内存对齐，以提高性能，保证所有成员变量都按照内存对齐规则进行存储和访问。
现代编译器会自动进行内存对齐，但是也可以通过`#pragma pack(n)`来指定内存对齐方式。

[结构体内存对齐](../.CodeReference/sizeof/sizeof_struct_align.cpp)

### 空结构体/类占用多少内存呢？为什么？

**空结构体/类占用1字节**
C++标准要求每个对象都必须有唯一的地址。如果空对象占用0字节，多个对象会共享同一个地址，这违反了语言规范。
**不包含虚函数/纯虚函数的类占用1字节**
由于成员函数只存在于代码段中，不存储于对象中，因此他们不占用对象的内存空间。
**包含虚函数的类占用4/8字节**
包含虚函数的类，在对象中存储一个指向虚函数表的指针，这个指针占用4/8字节。这个虚函数表(vtable)包含所有虚函数的地址，因此需要占用内存。

[空结构体/类占用多少内存](../.CodeReference/sizeof/sizeof_empty_struct.cpp)

### 请你解释一下类继承在内存中的表现

好的，这是一个很好的问题。类继承在内存中的表现确实是C++的核心概念之一，我从几个方面来解释一下。

**首先说说最简单的情况——空类继承**
你知道，一个空类虽然什么都没有，但它还是要占用1个字节的，这是为了保证每个对象都有唯一的地址。不过有趣的是，当你继承一个空类的时候，编译器会做一个叫EBO（空基类优化）的操作，这样派生类就不会为这个空基类浪费额外的空间了。

比如说，如果我定义一个EmptyBase空类，它占1字节，然后让EmptyDerived继承它，EmptyDerived还是只占1字节，不会变成2字节。

**然后是最常见的单继承**
这个就比较直观了。在内存中，派生类对象就像是把基类和派生类的成员"拼接"在一起，基类的部分总是在前面，派生类自己的成员在后面。这样设计的好处是，你可以很容易地把派生类指针转换成基类指针，因为它们的起始地址是一样的。

举个例子，如果Base类有一个int成员占4字节，Derived类继承Base并添加一个int成员，那么Derived就是8字节，内存布局就是先放基类的int，然后紧接着放派生类的int。

**接下来是虚函数的影响**
这个就有点复杂了。一旦你的类里有虚函数，编译器就会在对象里加一个指针，叫做虚函数表指针（vptr），它指向一个包含所有虚函数地址的表。这个指针通常放在对象的最开头，在64位系统上是8字节。派生类会和基类共用这个虚函数表指针。

比如说，一个有虚函数的基类，包含一个虚函数表指针8字节加上一个int成员4字节，总共是12字节，考虑内存对齐的话可能是16字节。

**多继承就更有意思了**
如果你同时继承多个基类，那么在内存中就会按照你写继承列表的顺序，把各个基类的成员依次排列。每个基类部分都是连续的，最后才是派生类自己的成员。这里要注意内存对齐的问题。

比如说，BaseA有个int占4字节，BaseB有个char占1字节，Multi类继承这两个基类并有个double成员。内存布局可能是：先放BaseA的4字节，然后BaseB的1字节加3字节填充，最后是派生类的8字节double。

**最后是虚继承**
这个是为了解决菱形继承问题的。当你用virtual关键字继承的时候，编译器会确保虚基类在整个继承层次中只有一份拷贝。为了实现这个，它会用虚基类表指针（vbptr）来间接访问虚基类成员。这样做的代价是增加了复杂性和一些性能开销。

举个菱形继承的例子：假设有个VBase虚基类，然后VA和VB都虚继承VBase，最后Diamond类继承VA和VB。这种情况下，Diamond对象只会包含一份VBase的拷贝，通过虚基类表指针来访问，避免了二义性问题。

**总的来说**，理解这些内存布局对性能优化很重要。比如说，虚继承虽然解决了菱形继承问题，但确实会带来性能开销，所以在设计的时候要权衡。另外，合理安排成员变量的顺序可以减少因为内存对齐造成的空间浪费。

我们项目中就用过sizeof和地址打印来验证内存布局，这对调试很有帮助。

[类继承在内存中的表现](../.CodeReference/sizeof/sizeof_inheritance.cpp)

<!-- 
### 虚函数对类大小的影响
[代码实现与总结](../.CodeReference/sizeof/sizeof_virtual.cpp)

### 多维数组的sizeof
[代码实现与总结](../.CodeReference/sizeof/sizeof_2d_array.cpp)

### 字符串字面量与sizeof
[代码实现与总结](../.CodeReference/sizeof/sizeof_string_literal.cpp)

### sizeof和动态分配内存
[代码实现与总结](../.CodeReference/sizeof/sizeof_dynamic_array.cpp)

### 联合体的sizeof
[代码实现与总结](../.CodeReference/sizeof/sizeof_union.cpp)

### 函数类型与sizeof
[代码实现与总结](../.CodeReference/sizeof/sizeof_function.cpp)
 -->
