# 循环展开优化技术

## 什么是循环展开
循环展开（Loop Unrolling）是将循环体内的操作重复多次，减少循环控制变量的判断和跳转次数的编译器优化技术。

## 优化原理

### 减少分支开销
- **问题**：每次循环都需要检查循环条件和跳转
- **解决**：通过展开减少分支判断次数
- **示例**：
```cpp
// 原始循环
for (int i = 0; i < n; i++) {
    c[i] = a[i] + b[i];
}

// 4倍展开后
for (int i = 0; i < n; i += 4) {
    c[i] = a[i] + b[i];
    c[i+1] = a[i+1] + b[i+1];
    c[i+2] = a[i+2] + b[i+2];
    c[i+3] = a[i+3] + b[i+3];
}
```

### 提高指令级并行度
- **流水线优化**：CPU可以并行执行多条无依赖的指令
- **SIMD支持**：便于编译器生成向量化指令
- **减少流水线停顿**：减少因分支预测失败导致的性能损失

### 编译器优化机会
- **寄存器重用**：更多机会重用寄存器中的数据
- **指令重排**：编译器有更大的优化空间
- **常量折叠**：部分计算可在编译期完成

## 应用场景

### 矩阵乘法优化
```cpp
// 内层循环展开
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        for (int k = 0; k < n; k += 4) {
            c[i][j] += a[i][k] * b[k][j] +
                       a[i][k+1] * b[k+1][j] +
                       a[i][k+2] * b[k+2][j] +
                       a[i][k+3] * b[k+3][j];
        }
    }
}
```

### 数值计算
```cpp
// SIMD友好的展开
for (int i = 0; i < n; i += 8) {
    // 8个元素同时处理，便于AVX指令集优化
    __m256 va = _mm256_load_ps(&a[i]);
    __m256 vb = _mm256_load_ps(&b[i]);
    __m256 vc = _mm256_add_ps(va, vb);
    _mm256_store_ps(&c[i], vc);
}
```

## 注意事项

### 展开因子选择
- **过小**：优化效果有限
- **过大**：代码膨胀，缓存效率下降
- **常见因子**：2、4、8，根据具体硬件调整

### 边界处理
```cpp
int main_loop = n - (n % 4);
// 主循环：4倍展开
for (int i = 0; i < main_loop; i += 4) {
    // 展开的循环体
}
// 剩余元素处理
for (int i = main_loop; i < n; i++) {
    // 单个元素处理
}
```

## 性能收益
- **理论提升**：减少25%-75%的分支开销（取决于展开倍数）
- **实际效果**：在计算密集型循环中可获得20%-50%的性能提升
- **硬件相关**：现代CPU的流水线和预测能力越强，收益越明显

## 编译器支持
- **GCC**：`-funroll-loops`自动展开
- **手动控制**：`#pragma GCC unroll n`指定展开倍数
- **Intel编译器**：`#pragma unroll`更精细的控制 