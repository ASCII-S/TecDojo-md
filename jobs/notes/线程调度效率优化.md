# 线程调度效率优化

## 问题背景
多线程并行时，合理的任务划分和调度能减少线程间的等待和负载不均，从而提升整体性能。

## 优化方法

### OpenMP调度策略

#### static调度
- **特点**：循环迭代均匀分配给各线程
- **适用场景**：每次计算量相近的场景
- **优势**：调度开销小，简单高效
- **示例**：
```cpp
#pragma omp parallel for schedule(static)
for (int i = 0; i < n; i++) {
    // 计算量相等的任务
}
```

#### dynamic调度
- **特点**：线程空闲后动态获取新任务
- **适用场景**：负载不均的场景
- **优势**：负载均衡
- **劣势**：有调度开销
- **示例**：
```cpp
#pragma omp parallel for schedule(dynamic, chunk_size)
for (int i = 0; i < n; i++) {
    // 计算量不等的任务
}
```

#### guided调度
- **特点**：动态分配，块大小逐步减小
- **优势**：兼顾负载均衡和调度开销
- **适用场景**：负载逐渐减少的场景

### 分块并行策略
- **原理**：将矩阵分块，每个线程处理一个或多个块
- **优势**：
  - 减少线程间竞争和同步
  - 提升数据局部性
  - 便于负载均衡
- **实现**：
```cpp
#pragma omp parallel for
for (int block = 0; block < total_blocks; block++) {
    int start_row = block * block_size;
    int end_row = min((block + 1) * block_size, matrix_size);
    // 处理该块的矩阵乘法
}
```

## 核心原理
提升线程调度效率的关键是：
1. **负载均衡**：确保各线程工作量大致相等
2. **减少同步等待**：最小化线程间的依赖和等待时间
3. **合理的粒度**：任务粒度既不能太大（负载不均）也不能太小（调度开销大）

## 性能影响
- 良好的线程调度可显著提升多核CPU利用率
- 减少线程空闲时间，提升整体吞吐量
- 在矩阵乘法等计算密集型任务中效果尤为明显 